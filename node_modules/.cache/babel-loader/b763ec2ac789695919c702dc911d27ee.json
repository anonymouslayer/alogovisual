{"ast":null,"code":"import PriorityQueue from \"js-priority-queue\";\n\nfunction isInsideGrid(i, j, grid) {\n  return i >= 0 && i < grid.length && j >= 0 && j < grid[0].length;\n}\n\nconst dijkstra = (grid, startNode, endNode) => {\n  let arr = grid;\n  let visited_nodes = [];\n  let shortestPath = [];\n  let start_node = startNode;\n  let end_node = endNode;\n  let pq = new PriorityQueue({\n    comparator: function (a, b) {\n      return a.distance - b.distance;\n    }\n  });\n\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[0].length; j++) {\n      arr[i][j].distance = Infinity;\n      arr[i][j].prevNode = null;\n      arr[i][j].isVisited = false;\n      arr[i][j].isShortestPath = false;\n    }\n  }\n\n  arr[start_node[0]][start_node[1]].distance = 0;\n  pq.queue(arr[start_node[0]][start_node[1]]);\n  let dx = [1, 0, -1, 0];\n  let dy = [0, 1, 0, -1]; // console.log(set.toArray())\n\n  let limit = 0;\n\n  while (pq.length) {\n    let cell = pq.dequeue();\n    if (arr[cell.row][cell.col].isVisited) continue;\n    arr[cell.row][cell.col].isVisited = true;\n    visited_nodes.push(cell);\n    let flag = 0;\n\n    for (let i = 0; i < 4; i++) {\n      let x = cell.row + dx[i];\n      let y = cell.col + dy[i];\n      if (!isInsideGrid(x, y, arr)) continue;\n\n      if (!arr[x][y].isVisited && (!arr[x][y].isWall || x == end_node[0] && y == end_node[1])) {\n        if (x === end_node[0] && y === end_node[1]) {\n          arr[x][y].isVisited = true;\n          arr[x][y].prevNode = arr[cell.row][cell.col];\n          let node = arr[x][y];\n\n          while (node !== null) {\n            shortestPath.unshift(node);\n            node = node.prevNode;\n\n            if (node) {\n              node.isShortestPath = true;\n              node.isVisited = false;\n            }\n          }\n\n          flag = 1;\n          break;\n        }\n\n        const dist = Math.abs(dx[i]) === 1 && Math.abs(dy[i]) === 1 ? 1.4 : 1;\n\n        if (cell.distance + dist < arr[x][y].distance) {\n          arr[x][y].prevNode = cell;\n          arr[x][y].distance = cell.distance + dist;\n        }\n\n        pq.queue(arr[x][y]);\n      }\n    }\n\n    if (flag == 1) break;\n  }\n\n  return {\n    visited_nodes,\n    shortestPath\n  };\n};\n\nexport default dijkstra;","map":{"version":3,"sources":["C:/Users/hp/Desktop/project/Algorithm-Visualizer/src/components/Pathfinding/algorithms/Dijkstra.js"],"names":["PriorityQueue","isInsideGrid","i","j","grid","length","dijkstra","startNode","endNode","arr","visited_nodes","shortestPath","start_node","end_node","pq","comparator","a","b","distance","Infinity","prevNode","isVisited","isShortestPath","queue","dx","dy","limit","cell","dequeue","row","col","push","flag","x","y","isWall","node","unshift","dist","Math","abs"],"mappings":"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","sourcesContent":["import PriorityQueue from \"js-priority-queue\";\r\nfunction isInsideGrid(i,j,grid)\r\n    { \r\n        return (i >= 0 && i < grid.length && j >= 0 && j < grid[0].length); \r\n    } \r\nconst dijkstra = (grid, startNode, endNode) => {\r\n    \r\n        let arr=grid;\r\n        let visited_nodes=[];\r\n        let shortestPath=[];\r\n        let start_node=startNode;\r\n        let end_node=endNode;\r\n        let pq=new PriorityQueue({\r\n            comparator:function(a,b){\r\n                return a.distance-b.distance;\r\n            }\r\n        });\r\n        for(let i=0;i<arr.length;i++){\r\n            for(let j=0;j<arr[0].length;j++){\r\n                arr[i][j].distance=Infinity;\r\n                arr[i][j].prevNode=null;\r\n                arr[i][j].isVisited=false;\r\n                arr[i][j].isShortestPath=false;\r\n            }\r\n        }\r\n        arr[start_node[0]][start_node[1]].distance=0;\r\n        pq.queue(arr[start_node[0]][start_node[1]]);\r\n        let dx = [1, 0, -1, 0]; \r\n        let dy = [0, 1, 0, -1]; \r\n        // console.log(set.toArray())\r\n        let limit=0;\r\n        \r\n        while(pq.length){\r\n            let cell=pq.dequeue();\r\n            if(arr[cell.row][cell.col].isVisited)continue;\r\n            arr[cell.row][cell.col].isVisited=true;\r\n            visited_nodes.push(cell);\r\n            let flag=0;\r\n            for(let i=0;i<4;i++){\r\n                let x=cell.row+dx[i];\r\n                let y=cell.col+dy[i];\r\n                if(!isInsideGrid(x,y,arr))continue;\r\n                if(!arr[x][y].isVisited&&(!arr[x][y].isWall||(x==end_node[0]&&y==end_node[1]))){\r\n                    if(x===end_node[0]&&y===end_node[1]){\r\n                        arr[x][y].isVisited=true;\r\n                        arr[x][y].prevNode=arr[cell.row][cell.col];\r\n                        let node=arr[x][y];\r\n                        while (node !== null) {\r\n                            shortestPath.unshift(node);\r\n                            node = node.prevNode;\r\n                            if (node){ node.isShortestPath = true;\r\n                                node.isVisited=false;\r\n                            }\r\n                        }\r\n                        flag=1;\r\n                        break;\r\n                    }\r\n                    const dist = Math.abs(dx[i]) === 1 && Math.abs(dy[i]) === 1 ? 1.4 : 1;\r\n                    if (cell.distance + dist < arr[x][y].distance) {\r\n                        arr[x][y].prevNode = cell;\r\n                        arr[x][y].distance = cell.distance + dist;\r\n                    }\r\n                    pq.queue(arr[x][y]);\r\n                }\r\n                \r\n            }\r\n            if(flag==1)break;\r\n            \r\n            \r\n        }\r\n        return {visited_nodes,shortestPath};\r\n}\r\nexport default dijkstra;"]},"metadata":{},"sourceType":"module"}